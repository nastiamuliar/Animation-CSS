# <a href="https://codeburst.io/learning-css-animations-with-a-touch-of-javascript-985a2404dc5e">CSS анімація</a>

CSS дійсно розвивався протягом багатьох років. У минулому його можно було використовувати лише для зміни простих статичних властивостей, таких як колір, розмір та стиль рамки . Він постійно вдосконалюється , і зараз ми знаходимось в точці, де можоивсті css анімації конкурують з JavaScript. Король мов веб розробки стає узурпованим(Влада короля мов веб розробки  в області анімації захоплена). Так, це звичайно перебільшення, але використання css анімації має багато переваг. Вони прості у використанні, без використання  таємничого js синтаксису (хоча API веб-анімації  повинна допомогти суровим js розробникам).CSS використовує удосконалену підтримку браузера та інтеграцію для автоматичної оптимізації при великих навантаженнях. Одна з речей, яку я ціную - це декларативний характер CSS при створенні анімації, та можливість вказати де буде анімація на кожному ключовому кадрі. Це полегшує візуалізацію коду.

Інша річ, яка мені подобається в CSS анімації це непогана підтримка браузерами. На даний час кожен повноцінний браузер, окрім Opera-Mini (ци можна його вважати повноцінним браузером) має підтримку СSS анімації.

![CSS Animation MDN](https://cdn-images-1.medium.com/max/800/1*-h8ZRKUONNb5iMegkGDzXw.png" src="https://cdn-images-1.medium.com/max/800/1*-h8ZRKUONNb5iMegkGDzXw.png)

Отже, тепер, коли ви знаєте, чому анімації CSS3 - це хороший інструмент у вашому ящику, почніть його використовувати.

Все починається з властивостей анімації для елемента. Властивість animation насправді є скороченням для цілого ряду інших властивостей. Синтаксис скорочень виглядає наступним чином:

<pre name="c932" id="c932" class="graf graf--pre graf-after--p">animation: <code class="markup--code markup--pre-code">duration | timing-function | delay | <br>iteration-count | direction | fill-mode | play-state | name;</code></pre>

Якщо вам здається що це надто багато не хвилюйтесь. Я поясню кожну підвластивість одна за одною.

<ul>
  <li>
    <b>animation-duration:</b>
    Час тривалості анімації. За замовчуванням 0,5 секунди - не дуже швидко і не дуже повільно;</li>
  <li>
    <b>animation-timing-function:</b> 
    Це те ж саме, що і функція синхронізації, яка використовується для переходів, визначає, наскільки швидко анімація рухається в   залежності від того, наскільки прогресує анімація. Наприклад  ease-in-out означає, що анімація буде повільніша на початку та в кінці анімаційної шкали часу. Щоб побачити  гарну візуалізацію функцій синхронізації відвідайте <a href="http://easings.net/uk">цей сайт</a>.
  </li>
  <li>
    <b>animation-delay:</b>
    Який часовий проміжок повинен пройти до початку анімації. Дайте браузеру про це знати, використовуючи цю властивість. Значення цієї властивості може бути вказане з секундах або мілісекундах. Це значення також може бути від’ємним, якщо ви хоче щоб анімацію почалась напівдорозі. Не знаю для чого це потрібно, але наявність такої можливості є досить круто.
</li>
  <li>
    <b>animation-iteration-count:</b>
    Кількість циклів (повторів) анімації. Ця  властивість переплітається animation-direction. Ви також можете використовувати десяткові     значення: якщо ви встановили анімацію, що здійснює поворот на 360 градусів, то значення 2.5 означатиме що поворот здійсниться на 180     градусів. Поєднання animation-direction і animation-iteration-count є хорошою можливістю для розуміння анімації. Для того щоб           спробувати створити власну анімацію з використанням animation-direction і animation-iteration-count властивостей перейдіть по           <a href="https://codepen.io/afrench53198/embed/preview/bLYXLR?default-tabs=css%2Cresult&embed-version=2&height=600&host=https%3A%2F%2Fcodepen.io&referrer=https%3A%2F%2Fcodeburst.io%2Fmedia%2F38f4970a90124d3303602c8e4b0e4e8c%3FpostId%3D985a2404dc5e&slug-hash=bLYXLR"v target="_blank">найступній ссилці</a>
  </li>
  <li>
    <b>animation-direction:</b>
     Ця властивість описує поведінку анімації між циклами. Значеннями цієї властивості можуть бути: <i>normal, reverse, alternate, and        alternate-reverse</i>. Спочатку важко зрозуміти, тому я поясню більш докладніше: <i>Normal</i> означає, що анімація починатиметься      спочатку на кожному циклі або ітерації. Іншими словами анімація відтворюватиметься від початку до кінця на кожному циклі.                <i>Reverse</i> - анімація відтворюватиметься в зворотньому порядку. <i>Alternate</i> - анімація буде відтворюватись спочатку в          прямому а потім зворотньому порядку, чергуючи.<i>Alternate-reverse</i>  означає, що анімація робить це перший цикл у зворотному          напрямку, а потім у прямому і в подальшому чергується в такому ж порядку.
  </li>
  <li>
    <b>animation-fill-mode:</b>
    Визначає стилі, які мають застосовутись до елементу, коли анімація не виконується (якщо кількість циклів не безмежна). Дозволяє         встановити стиль елементу, що відповідатиме стилю останнього ключового кадру анімації, що залежить вiд <b>animation-fill-mode</b>,       <b>animation-direction</b> i <b>animation-iteration-count</b>. Зв’язок між усіма властивостями найкращще проілюстрований в цих <a       href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode"> маленьких приємних табличках, зроблених Mozilla</a>.В       редакторі нижче зверніть увагу, як елемент із fill-mode forward залишається в тому ж  місці після завершення анімації.
    <a href="https://codepen.io/afrench53198/embed/preview/bLYXLR?default-tabs=css%2Cresult&embed-version=2&height=600&host=https%3A%2F%2Fcodepen.io&referrer=https%3A%2F%2Fcodeburst.io%2Fmedia%2F38f4970a90124d3303602c8e4b0e4e8c%3FpostId%3D985a2404dc5e&slug-hash=bLYXLR">link</a>
  </li>
  <li>
    <b>animation-play-state:</b>
    Основна функція цієї властивості -  відслідковувати, чи працює анімація чи призупинена. Це дозволяє призупинити анімацію і зберігати     її в поточному стані, а потім запускати її з цього стану. Це можна зробити, використовуючи ці два короткі блоки коду:
   *CSS:*
      ```javascript
      .paused {
        animation-play-state: paused;
      }
    ```
    *JS:*
    
     // Get references to element and controlling button
     var element = document.querySelector(".element"),
     button = document.querySelector(".buttonForElement");
     // toggle the paused class
     button.onclick = function () {
         element.classList.toggle("paused")
     }
   ```
  </li>
</ul>
  
Все це робить додавання класу .paused до відповідного елементу: зупиняє та відновлює анімацію натисканням кнопки. Перевірте поле 1 в редакторі, щоб отримати правильне уявлення про те, як це буде працювати в реальному контексті анімації.
  
 <a href="https://codepen.io/afrench53198/embed/preview/EQKyWL?default-tabs=css%2Cresult&embed-version=2&height=600&host=https%3A%2F%2Fcodepen.io&referrer=https%3A%2F%2Fcodeburst.io%2Fmedia%2F8edddeb361e2ed32080603becfb5c540%3FpostId%3D985a2404dc5e&slug-hash=EQKyWL">link</a>
 
 Чудово! Тепер, коли ви знаєте всі ці властивості, перейдемо до останньої (і найважливішої) підвластивості анімації: name.
Назва анімації виглядає як ім'я змінної або класу; це стосується поведінки анімації. Якщо ви робите анімацію вперше то для є необхідність для початку освоїти іншу тему…

@keyframes!

Так .. що таке правило @keyframes?

Я справді не хочу робити спроби пояснити це, тому MDN зробить це за мене:
"@keyframes CSS at-правила  керують проміжними кроками в анімаційній послідовності CSS, визначаючи стилі для ключових кадрів (або точок доступу) уздовж анімаційної послідовності. Це дає більший контроль над проміжними кроками анімаційної послідовності, ніж переходи. "

Отже, ми знаємо, що основні кадри - це спосіб надати чіткий контроль над анімацією в CSS. Як точно їх використовувати?

Ну, на  початку, у вас буде щось на зразок цього:


Це досить очевидно. Ви просто вказуєте стан властивості, яку ви хочете анімувати на визначеній точці під час анімації. Так це виглядає на практиці:


Дивіться цей код у дії, натиснувши "Показати"!

Тепер, коли ви знаєте, як створювати чудові анімації за допомогою ключових кадрів CSS, як ви керуєте цими анімаціями? Саме тут Javascript корисний.
Я покажу вам метод, за допомогою якого я це роблю, але я закликаю вас експериментувати та придумати більш багаторазові та більш чисті рішення. 

Це чотири етапи процесу:

Створіть анімацію
Додайте доступний клас CSS для перемикання за допомогою JS
За допомогою JS отримайте кнопку керування і/або власне елемент (однак ти хочеш керувати анімацією)
Об’єднайте це разом , міняючи клас за допомогою стану елементу/кнопки

Весь необхідний код (з деяким стилями), щоб зробити вікно та кнопку наведений в редакторі нижче.
Хоча це моє рішення в даний час, але безумовно, не найкраще. Codepen мав труднощі з методом addEventListener у Javascript, але це чудовий спосіб обробляти стан анімації, про що я міг би говорити в окремій статті. Я закликаю вас шукати більш кращі, більш модульні способи створення та управління анімаціями в CSS та Javascript. Якщо у вас є кращий спосіб, надішліть його в коментарі! Я завжди шукаю способи написання більш чистого і багаторазового використовуваного коду. Я сподіваюся, вам сподобалося читати! Якщо ця стаття допомагла вам, то кілька уподобань буде чудовою подякою:)

